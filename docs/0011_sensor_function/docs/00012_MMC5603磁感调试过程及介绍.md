# 概述

磁感sensor MMC5603 sensorhub调试记录

## 硬件

目前kernel端是通的，sensorhub通了，但是校准有问题。

| ITEM         | MMC5603NJL        |
| ------------ | ---------- |
| I2C总线及地址     | i2c1 0x30 |
| 供电 | VIO18_PUM |

![0005_磁力计原理图.png](images/0005_磁力计原理图.png)

## 1.校准库获取流程

* Hal层通过maglibinfo节点绑定进入到驱动层寻找库，并返回相应字符串，通过字符串找到对应的libxxx.so

```C++
//vendor\mediatek\proprietary\hardware\sensor\sensors-1.0\VendorInterface.cpp
VendorInterface::VendorInterface() {
    int fd = -1;
    int len = 0;
    char buf[64] = {0};
    struct mag_libinfo_t libinfo;
    struct magChipInfo chipinfo;
    SensorList *mSensorList = nullptr;

    ALOGI("VendorInterface constructor.");

    lib_interface = NULL;
    lib_handle = NULL;
    memset(&libinfo, 0, sizeof(struct mag_libinfo_t));
    memset(&chipinfo, 0, sizeof(struct magChipInfo));

    fd = TEMP_FAILURE_RETRY(open("/sys/class/sensor/m_mag_misc/maglibinfo", O_RDWR));
    if (fd >= 0) {
        len = TEMP_FAILURE_RETRY(read(fd, &libinfo, sizeof(struct mag_libinfo_t)));
        if (len <= 0) {
            ALOGE("read libinfo err, len = %d\n", len);
            close(fd);
            return;
        }
        close(fd);
    } else {
        ALOGE("open vendor libinfo fail\n");
        return;
    }
    libinfo.libname[LIB_NAME_LENGTH - 1] = '\0';
    if (!isValidLibName(libinfo.libname)) {
        ALOGE("invalid libname, length too long\n");
        return;
    }
    strlcpy(buf, "lib", sizeof(buf));
    strlcat(buf, libinfo.libname, sizeof(buf));
    strlcat(buf, ".so", sizeof(buf));

    lib_handle = dlopen(buf, RTLD_NOW);
    if (!lib_handle) {
        ALOGE("get lib_interface fail dlopen operation.\n");
        lib_handle = NULL;
        return;
    }
    dlerror();
    lib_interface = (struct mag_lib_interface_t *)dlsym(lib_handle, "MAG_LIB_API_INTERFACE");
    if (!lib_interface) {
        ALOGE("get lib_interface fail dlsym operation.\n");
        dlclose(lib_handle);
        lib_handle = NULL;
        return;
    }
    ALOGI("get lib_interface success.");

    mSensorList = SensorList::getInstance();
    chipinfo.hwGyro = mSensorList->hwGyroSupported();
    chipinfo.deviceid = libinfo.deviceid;
    chipinfo.layout = libinfo.layout;
    lib_interface->initLib(&chipinfo);
}
```

* 内核驱动通过判断不同机型设置相应的校正库名称

```C++
// kernel-4.19/drivers/misc/mediatek/sensors-1.0/magnetometer/mmc5603/mmc5603x.c
static int get_terminal_type(void)
{
	int i = 0;
	int ret = 0;
	char boot[BUFFER_LENGTH] = {'\0'};

	char *match = (char *) strnstr(saved_command_line,
				"androidboot.boardid=",
				strlen(saved_command_line));

	if (match) {
		memcpy(boot, (match + strlen("androidboot.boardid=")), BUFFER_LENGTH);

		for (i = 0; i < BUFFER_LENGTH; i++) {
			if (! ISDIGIT(boot[i])) {
				boot[i] = '\0';
				break;
			}
		}
		boot[BUFFER_LENGTH - 1] = '\0';

		MEMSIC_INFO("%s: androidboot.boardid string is %s\n", __func__, boot);
		if (kstrtoint(boot, 10, &ret) != 0)
			ret = 0;

	}
	MEMSIC_INFO("%s: androidboot.boardid is %d\n", __func__, ret);

	return ret;
}

static int mmc5603x_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    ...
    int terminal_type = get_terminal_type();
    if (((terminal_type >> 3) & 0x03) == TERMINAL_M50) {
        if ((terminal_type & 0x07) == TERMINAL_M50_PLASTIC) {
            strlcpy(ctl.libinfo.libname, "memsic9axis", sizeof(ctl.libinfo.libname));
            MEMSIC_INFO("%s: M50 memsic 6 axis plastic lib\n");
        } else {
            strlcpy(ctl.libinfo.libname, "memsic9axismetal", sizeof(ctl.libinfo.libname));
            MEMSIC_INFO("%s: M50 memsic 6 axis metal lib\n");
        }
    } else {
        strlcpy(ctl.libinfo.libname, "memsic", sizeof(ctl.libinfo.libname));
        MEMSIC_INFO("%s: M8 memsic 6 axis lib\n");
    }
    ctl.libinfo.deviceid = MMC5603x_DEVICE_ID;
    err = mag_register_control_path(&ctl);
    ...
}
```

```C++
// kernel-4.19/drivers/misc/mediatek/sensors-1.0/magnetometer/mag.c
static ssize_t maglibinfo_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct mag_context *cxt = mag_context_obj;

	if (!buf)
		return -1;
	memcpy(buf, &cxt->mag_ctl.libinfo, sizeof(struct mag_libinfo_t));
	return sizeof(struct mag_libinfo_t);
}
```

* SDK校正库文件路径：

  * vendor/mediatek/proprietary/hardware/sensor/sensors-1.0/algorithm/calibration/6axis/M8/lib64/libmemsic.so
  * vendor/mediatek/proprietary/hardware/sensor/sensors-1.0/algorithm/calibration/6axis/M50_metal/libmemsic9axismetal.so
  * vendor/mediatek/proprietary/hardware/sensor/sensors-1.0/algorithm/calibration/6axis/M50_plastic/libmemsic9axis.so

* 设备中的校正库文件路径：
  * vendor/lib64/libmemsic.so
  * vendor/lib64/libmemsic9axis.so
  * vendor/lib64/libmemsic9axismetal.so

### 校准库获取优化

* 校准库兼容M50/M8直接通过读取设备节点，这样做的弊端就是，kernel磁感5603驱动关闭了或者更换型号，就无法通过节点read的方式获取校准库名称了，应该直接在hal层做兼容工作，优化如下：

```C++
void SensorList::initSensorList(void) {
    struct sensor_t sensor;
    char value[PROPERTY_VALUE_MAX];
/*
    struct mag_libinfo_t libinfo;
    int fd = -1;

    memset(&libinfo, 0, sizeof(struct mag_libinfo_t));

    fd = open("/sys/class/sensor/m_mag_misc/maglibinfo", O_RDWR);
    if (fd >= 0) {
        read(fd, &libinfo, sizeof(struct mag_libinfo_t));
        close(fd);

        if (strcmp(libinfo.libname, "memsic") == 0)
            terminal_type = 1;

        ALOGD("%s libinfo.libname: %s, terminal_type: %d\n", __func__, libinfo.libname, terminal_type);
    } else {
        ALOGD("%s open vendor libinfo fail\n", __func__);
    }
*/
    property_get("ro.boot.terminal_name", value, ""); //修改这块
    if (strcmp(value, "M8") == 0) {
        terminal_type = 1;;
    }
    ALOGD("%s  terminal_type: %d\n", __func__,  terminal_type);

```